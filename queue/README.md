# Azureのメッセージングサービス4種
https://qiita.com/gtracker64/items/b54c43ce5fe41fd4bd47


## メッセージ系
https://learn.microsoft.com/ja-jp/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted

### Queue Storage
- シンプルなメッセージキュー
- AzureStorageを利用
- データ量が多い場合
  - 無制限のキューサイズ
- RESTベース
- ストレージの容量で課金
- 単一の送信先
- キューに対して実行されたすべてのトランザクションのサーバー側のログが必要


## Service Bus
### キュー：
- 単一の受信者
- 柔軟なキュー
- 容量は最大80GB
- 以下のいずれかを選択可能
  - At-Least-Once：最低1回（重複あり、損失なし）
    - 少なくとも1回。つまり1回は確実に配信されるが、重複(２回以上同じメッセージ)がありうる。
  - At-Most-Once：最大1回（重複なし、損失あり）
    - 最大1回。つまり0回=配信されないことがある。重複はない。
- トランザクションあり（複数メッセージをグループ化できる）
- 先入れ先出し法（FIFO）の保証
- 信頼性向上
  - 非同期に処理できる
- 自動重複検出をサポートしている
- AMQPを使う場合
- 最終的には、キューベースのポイントツーポイント通信から、パブリッシュ/サブスクライブ メッセージング パターンへの移行を想定している場合。 このパターンは、追加の受信者 (サブスクライバー) の統合を可能にします。 各受信者は、キューに送信されたメッセージの一部またはすべての独立したコピーを受け取ります。
- ソリューションで、バッチ メッセージの発行および使用が必要な場合。
- 
- ソリューションで、キューをポーリングせずにメッセージを受信できる必要がある場合。 Service Bus では、Service Bus がサポートする TCP ベースのプロトコルを使用し、長いポーリングの受信操作を使用することによってこれを実現できます。
- アプリケーションでメッセージを実行時間の長い並列ストリームとして処理する必要がある場合 (メッセージは、それ自体の [セッション ID] プロパティを使用してストリームに関連付けられます)。 このモデルでは、処理を行うアプリケーションの各ノードは、メッセージではなくストリームに対して競合します。 処理を行うノードにストリームが渡されると、そのノードはトランザクションを使用してアプリケーション ストリームの状態を確認できます。
- ロールベースのアクセス モデルを提供して、キューの送信側と受信側に異なる権限/アクセス許可を与える必要がある場合。


### トピック：
- 複数の受信者
- 複数クライアントからのサブスク・処理が可能

## Queue Storage or Service Bus
- Queueストレージを選択（最も単純)
  - データ量が多い(キューのサイズが80GBを超える)
  - 簡単にコーディングできるシンプルなキューがほしい

- Service Busキューを選択
  - At-Most-Once保証(最大1回、重複なし)が必要
  - 順序保証(FIFO)が必要
  - トランザクションが必要（全て処理される or 何も処理されない)
  - データ量が比較的少ない(キューのサイズが80GB未満)

- Service Busトピックを選択（最も複雑）
  - 複数のサブスクライバー（受信者）が必要


ｆ
## 検討事項
- どれくらいの容量使うのだろう。80GBで十分か？
  - 十分だと思う。（1出荷指示_KB　×　_指示数）
- At-Most-Onceがいるのか？
  - いらん
- FIFOが保証必要か？
  - 必要
- メッセージが到着したら通知してくれる機能が必要がどうか
  - 一旦不要そうだがあったほうがよさそう
⇛「Service Bus」

# イベント系
## Event Grid：
- シンプルなイベント

## Event Hubs：
- 高スループット、多数のパブリッシャー、セキュリティ、回復性を持つイベント

